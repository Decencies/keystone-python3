/*
 * Copyright (c) 2018 Jämes Ménétrey <james@menetrey.me>
 *
 * This file is part of the Keystone Java bindings which is released under MIT.
 * See file LICENSE in the Java bindings folder for full license details.
 */

package keystone;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import keystone.exceptions.OpenFailedKeystoneException;
import keystone.jna.KeystoneTypeMapper;
import keystone.natives.CleanerContainer;
import keystone.natives.KeystoneCleanerContainer;
import keystone.natives.KeystoneNative;
import keystone.utilities.Version;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * The Keystone engine.
 */
public class Keystone implements AutoCloseable {
    /**
     * The native proxy for calling the C library.
     */
    private final KeystoneNative ksNative;

    /**
     * The pointer to the Keystone native resource.
     */
    private final Pointer ksEngine;

    /**
     * The cleaner container that frees up the native resource if this object is not properly closed and is
     * candidate for garbage collection.
     */
    private final CleanerContainer ksEngineCleaner;

    /**
     * Indicates whether the current instance of Keystone has been closed.
     */
    private final AtomicBoolean hasBeenClosed;

    /**
     * Initializes a new instance of the class {@link Keystone}.
     *
     * @param architecture The architecture of the code generated by Keystone.
     * @param mode         The mode type.
     * @throws OpenFailedKeystoneException if the Keystone library cannot be opened properly.
     */
    public Keystone(KeystoneArchitecture architecture, KeystoneMode mode) {
        ksNative = initializeKeystoneNativeProxy();
        ksEngine = initializeKeystoneEngine(architecture, mode);
        ksEngineCleaner = initializeKeystoneCleanerContainer();
        hasBeenClosed = new AtomicBoolean(false);
    }

    /**
     * Initializes the JNA proxy to call original library functions.
     */
    private KeystoneNative initializeKeystoneNativeProxy() {
        Map<String, Object> options = new HashMap<>();
        options.put(Library.OPTION_TYPE_MAPPER, new KeystoneTypeMapper());

        return Native.loadLibrary("keystone", KeystoneNative.class, options);
    }

    /**
     * Opens an handle of Keystone.
     *
     * @param architecture The architecture of the code generated by Keystone.
     * @param mode         The mode type.
     * @return The return value is a pointer to the handle of Keystone.
     */
    private Pointer initializeKeystoneEngine(KeystoneArchitecture architecture, KeystoneMode mode) {
        var pointerToEngine = new PointerByReference();
        var openResult = ksNative.ks_open(architecture, mode, pointerToEngine);

        if (openResult != KeystoneError.Ok) {
            throw new OpenFailedKeystoneException(openResult);
        }

        return pointerToEngine.getValue();
    }

    /**
     * Initializes the cleaner object, that is going to close the native handle of Keystone if
     * the instance is garbage collected.
     *
     * @return The return value is a cleaner container.
     */
    private CleanerContainer initializeKeystoneCleanerContainer() {
        return new KeystoneCleanerContainer(ksEngine, ksNative);
    }

    /**
     * Gets the major and minor version numbers.
     *
     * @return The returned value is an instance of the class {@link Version}, containing the major and minor version numbers.
     */
    public Version version() {
        var major = new IntByReference();
        var minor = new IntByReference();

        ksNative.ks_version(major, minor);

        return new Version(major.getValue(), minor.getValue());
    }

    /**
     * Closes this resource, relinquishing any underlying resources.
     * This method is invoked automatically on objects managed by the
     * {@code try}-with-resources statement.
     * <p>
     * The call to this method is thread-safe.
     */
    @Override
    public void close() {
        var hasBeenAlreadyClosed = hasBeenClosed.getAndSet(true);

        if (!hasBeenAlreadyClosed) {
            ksEngineCleaner.close();
        }
    }
}
